# frozen_string_literal: true

# Represents a single prescription and tracks its state
# Belongs to a Patient (has_one patient)
class Prescription
  attr_reader :patient, :drug_name

  # Initializes a new Prescription instance
  #
  # This method sets up the prescription with its associated patient and drug name,
  # and initializes all state tracking variables to their default values. It validates
  # that the patient is a valid Patient instance and that the drug name is not nil or empty.
  #
  # @param patient [Patient] The patient this prescription belongs to
  # @param drug_name [String] The name of the drug being prescribed
  # @raise [ArgumentError] if patient is nil, not a Patient instance, or drug_name is invalid
  def initialize(patient:, drug_name:)
    validate_patient!(patient)
    validate_drug_name!(drug_name)

    @patient = patient
    @drug_name = drug_name
    @created = false
    @fill_count = 0
    @return_count = 0
  end

  # Returns the name of the patient associated with this prescription
  #
  # This method provides a convenient way to access the patient's name without
  # directly accessing the patient object. It maintains encapsulation while
  # allowing the prescription to expose patient information when needed.
  #
  # @return [String] The name of the patient
  def patient_name
    @patient.name
  end

  # Checks if this prescription has been created
  #
  # This method is used to determine if a prescription has been initialized with
  # a 'created' event. This is important because prescriptions must be created
  # before they can be filled or returned, enforcing business rules.
  #
  # @return [Boolean] true if the prescription has been created, false otherwise
  def created?
    @created
  end

  # Marks this prescription as created
  #
  # This method is called when a 'created' event is processed for this prescription.
  # It sets the internal flag that allows subsequent fill and return operations to proceed.
  # This enforces the business rule that prescriptions must be created before they can
  # be filled or returned.
  def mark_created
    @created = true
  end

  # Processes a fill event for this prescription
  #
  # This method increments the fill count when a prescription is filled. It enforces
  # the business rule that a prescription must be created before it can be filled by
  # returning nil if the prescription hasn't been created yet. Returns self on success
  # to allow method chaining, or nil on failure.
  #
  # @return [Prescription, nil] self on success, nil if prescription hasn't been created
  def fill
    return nil unless @created

    @fill_count += 1
    self
  end

  # Processes a return event for this prescription
  #
  # This method increments the return count when a filled prescription is returned.
  # It enforces multiple business rules:
  # 1. The prescription must be created before it can be returned
  # 2. There must be at least one fill that hasn't been returned yet
  # This prevents returning more prescriptions than have been filled. Returns self on
  # success to allow method chaining, or nil on failure.
  #
  # @return [Prescription, nil] self on success, nil if prescription hasn't been created
  #                            or if there are no fills available to return
  def return_fill
    return nil unless @created
    return nil if @fill_count <= @return_count

    @return_count += 1
    self
  end

  # Calculates the net number of fills (fills minus returns)
  #
  # This method computes the effective number of fills by subtracting returns from
  # total fills. This is used in income calculations and reporting to show the
  # actual number of prescriptions that were successfully filled and not returned.
  #
  # @return [Integer] The net number of fills (fill_count - return_count)
  def net_fills
    @fill_count - @return_count
  end

  # Calculates the income generated by this prescription
  #
  # This method computes the total income based on fills and returns. The business
  # logic is:
  # - Each fill generates $5 in income
  # - Each return cancels the income from a fill AND incurs a $1 cost
  # The formula: (net_fills * 5) - (return_count * 1) ensures that returns both
  # cancel the fill income and add a penalty cost.
  #
  # @return [Integer] The total income (can be negative if returns exceed fills)
  def income
    # Each fill gives $5, but returns cancel the income from the fill AND cost $1
    # So: (net_fills * 5) - (return_count * 1)
    # This means: (fill_count - return_count) * 5 - return_count * 1
    (net_fills * 5) - (@return_count * 1)
  end

  private

  # Validates that the patient parameter is a valid Patient instance
  #
  # This method ensures data integrity by checking that the patient is not nil
  # and is an instance of the Patient class. This prevents invalid prescriptions
  # from being created and maintains the relationship between Prescription and Patient.
  #
  # @param patient [Object] The patient object to validate
  # @raise [ArgumentError] if patient is nil or not a Patient instance
  def validate_patient!(patient)
    raise ArgumentError, 'patient cannot be nil' if patient.nil?
    raise ArgumentError, 'patient must be an instance of Patient' unless patient.is_a?(Patient)
  end

  # Validates that the drug_name parameter is valid
  #
  # This method ensures that the drug name is not nil and not an empty string
  # (after stripping whitespace). This prevents prescriptions with invalid drug
  # names from being created, maintaining data quality.
  #
  # @param drug_name [Object] The drug name to validate
  # @raise [ArgumentError] if drug_name is nil or empty
  def validate_drug_name!(drug_name)
    raise ArgumentError, 'drug_name cannot be nil' if drug_name.nil?
    raise ArgumentError, 'drug_name cannot be empty' if drug_name.to_s.strip.empty?
  end
end
